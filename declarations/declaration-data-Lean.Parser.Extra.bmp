{"name":"Lean.Parser.Extra","instances":[],"imports":["Init","Lean.Parser.Extension","Lean.PrettyPrinter.Parenthesizer","Lean.PrettyPrinter.Formatter"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L288-L288","name":"Lean.Parser.«termRegister_parser_alias(Kind:=_)______»","line":288,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.«termRegister_parser_alias(Kind:=_)______»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.«termRegister_parser_alias(Kind:=_)______»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">«termRegister_parser_alias(Kind:=_)______»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L273-L277","name":"Lean.ppHardLineUnlessUngrouped.formatter","line":273,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppHardLineUnlessUngrouped.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppHardLineUnlessUngrouped.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppHardLineUnlessUngrouped</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L268-L272","name":"Lean.ppDedentIfGrouped.formatter","line":268,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppDedentIfGrouped.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppDedentIfGrouped.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppDedentIfGrouped</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L266-L267","name":"Lean.ppAllowUngrouped.formatter","line":266,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppAllowUngrouped.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppAllowUngrouped.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppAllowUngrouped</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L262-L264","name":"Lean.ppDedent.formatter","line":262,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppDedent.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppDedent.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppDedent</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L261-L261","name":"Lean.ppIndent.formatter","line":261,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppIndent.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppIndent.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppIndent</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L260-L260","name":"Lean.ppRealGroup.formatter","line":260,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppRealGroup.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppRealGroup.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppRealGroup</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L259-L259","name":"Lean.ppRealFill.formatter","line":259,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppRealFill.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppRealFill.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppRealFill</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L258-L258","name":"Lean.ppLine.formatter","line":258,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppLine.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppLine.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppLine</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L257-L257","name":"Lean.ppSpace.formatter","line":257,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppSpace.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppSpace.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppSpace</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L256-L256","name":"Lean.ppHardSpace.formatter","line":256,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.ppHardSpace.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppHardSpace.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppHardSpace</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L249-L249","name":"Lean.Parser.ppHardLineUnlessUngrouped","line":249,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppHardLineUnlessUngrouped","doc":"No-op parser combinator that prints a line break.\nThe line break is soft if the combinator is followed\nby an ungrouped parser (see ppAllowUngrouped), otherwise hard. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppHardLineUnlessUngrouped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppHardLineUnlessUngrouped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L243-L243","name":"Lean.Parser.ppDedentIfGrouped","line":243,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppDedentIfGrouped","doc":"No-op parser combinator that advises the pretty printer to dedent the given syntax,\nif it was grouped by the category parser.\nDedenting can in particular be used to counteract automatic indentation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppDedentIfGrouped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppDedentIfGrouped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L237-L237","name":"Lean.Parser.ppAllowUngrouped","line":237,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppAllowUngrouped","doc":"No-op parser combinator that allows the pretty printer to omit the group and\nindent operation in the enclosing category parser.\n```\nsyntax ppAllowUngrouped \"by \" tacticSeq : term\n-- allows a `by` after `:=` without linebreak in between:\ntheorem foo : True := by\n  trivial\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppAllowUngrouped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppAllowUngrouped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L225-L225","name":"Lean.Parser.ppDedent","line":225,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppDedent","doc":"No-op parser combinator that advises the pretty printer to dedent the given syntax.\nDedenting can in particular be used to counteract automatic indentation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppDedent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppDedent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L221-L221","name":"Lean.Parser.ppGroup","line":221,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppGroup","doc":"No-op parser combinator that advises the pretty printer to group and indent the given syntax.\nBy default, only syntax categories are grouped. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppGroup\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppGroup</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L217-L217","name":"Lean.Parser.ppIndent","line":217,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppIndent","doc":"No-op parser combinator that advises the pretty printer to indent the given syntax without grouping it. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppIndent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppIndent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L215-L215","name":"Lean.Parser.ppRealGroup","line":215,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppRealGroup","doc":"No-op parser combinator that advises the pretty printer to emit a `Format.group` node. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppRealGroup\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppRealGroup</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L213-L213","name":"Lean.Parser.ppRealFill","line":213,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppRealFill","doc":"No-op parser combinator that advises the pretty printer to emit a `Format.fill` node. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppRealFill\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppRealFill</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L211-L211","name":"Lean.Parser.ppLine","line":211,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppLine","doc":"No-op parser that advises the pretty printer to emit a hard line break. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppLine\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppLine</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L209-L209","name":"Lean.Parser.ppSpace","line":209,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppSpace","doc":"No-op parser that advises the pretty printer to emit a space/soft line break. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppSpace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppSpace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L207-L207","name":"Lean.Parser.ppHardSpace","line":207,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppHardSpace","doc":"No-op parser that advises the pretty printer to emit a non-breaking space. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppHardSpace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppHardSpace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L204-L204","name":"Lean.Parser.patternIgnore","line":204,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.patternIgnore","doc":"No-op parser combinator that annotates subtrees to be ignored in syntax patterns. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.patternIgnore\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">patternIgnore</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L200-L201","name":"Lean.Parser.notSymbol","line":200,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.notSymbol","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.notSymbol\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">notSymbol</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L196-L196","name":"Lean.Parser.sepBy1Indent.formatter","line":196,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">sepBy1Indent</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(_sep : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pSep : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L182-L194","name":"Lean.Parser.sepByIndent.formatter","line":182,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.sepByIndent.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.sepByIndent.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">sepByIndent</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(_sep : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pSep : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L176-L178","name":"Lean.Parser.sepBy1Indent","line":176,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">sepBy1Indent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(sep : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(psep : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> (<span class=\"fn\"><a href=\"./Lean/Parser/Basic.html#Lean.Parser.symbol\">Lean.Parser.symbol</a> <span class=\"fn\">sep</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(allowTrailingSep : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L172-L174","name":"Lean.Parser.sepByIndent","line":172,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.sepByIndent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.sepByIndent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">sepByIndent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(sep : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(psep : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> (<span class=\"fn\"><a href=\"./Lean/Parser/Basic.html#Lean.Parser.symbol\">Lean.Parser.symbol</a> <span class=\"fn\">sep</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(allowTrailingSep : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L169-L170","name":"Lean.Parser.manyIndent","line":169,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.manyIndent","doc":"The parser `manyIndent(p)` is equivalent to `withPosition((colGe p)*)`. This has the effect of\nparsing zero or more occurrences of `p`, where each subsequent `p` parse needs to be indented\nthe same or more than the first parse.\n\nThis parser has arity 1, and returns a list of the results from `p`.\n`p` is \"auto-grouped\" if it is not arity 1. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.manyIndent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">manyIndent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L160-L161","name":"Lean.Parser.many1Indent","line":160,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.many1Indent","doc":"The parser `many1Indent(p)` is equivalent to `withPosition((colGe p)+)`. This has the effect of\nparsing one or more occurrences of `p`, where each subsequent `p` parse needs to be indented\nthe same or more than the first parse.\n\nThis parser has arity 1, and returns a list of the results from `p`.\n`p` is \"auto-grouped\" if it is not arity 1. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.many1Indent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">many1Indent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L151-L152","name":"Lean.Parser.group","line":151,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.group","doc":"The parser `group(p)` parses the same thing as `p`, but it wraps the results in a `groupKind`\nnode.\n\nThis parser always has arity 1, even if `p` does not. Parsers like `p*` are automatically\nrewritten to `group(p)*` if `p` does not have arity 1, so that the results from separate invocations\nof `p` can be differentiated. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.group\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">group</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L142-L143","name":"Lean.Parser.nameLit","line":142,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.nameLit","doc":"The parser `name` parses a name literal like `` `foo``. The syntax is the same as for identifiers\n(see `ident`) but with a leading backquote.\n\nThis parser has arity 1: it produces a `nameLitKind` node containing the raw literal\n(including the backquote).\nYou can use `TSyntax.getName` to extract the name from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.nameLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">nameLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L133-L134","name":"Lean.Parser.charLit","line":133,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.charLit","doc":"The parser `char` parses a character literal, such as `'a'` or `'\\n'`. Character literals can\ncontain C-style escapes like `\\n`, `\\\"`, `\\x00` or `\\u2665`, as well as literal unicode characters\nlike `∈`, but must evaluate to a single unicode codepoint, so `'♥'` is allowed but `'❤️'` is not\n(since it is two codepoints but one grapheme cluster).\n\nThis parser has arity 1: it produces a `charLitKind` node containing an atom with the raw\nliteral (including the quote marks and without interpreting the escapes).\nYou can use `TSyntax.getChar` to decode the string from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.charLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">charLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L122-L123","name":"Lean.Parser.strLit","line":122,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.strLit","doc":"The parser `str` parses a string literal, such as `\"foo\"` or `\"\\r\\n\"`. Strings can contain\nC-style escapes like `\\n`, `\\\"`, `\\x00` or `\\u2665`, as well as literal unicode characters like `∈`.\nNewlines in a string are interpreted literally.\n\nThis parser has arity 1: it produces a `strLitKind` node containing an atom with the raw\nliteral (including the quote marks and without interpreting the escapes).\nYou can use `TSyntax.getString` to decode the string from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.strLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">strLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L112-L113","name":"Lean.Parser.scientificLit","line":112,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.scientificLit","doc":"The parser `scientific` parses a scientific-notation literal, such as `1.3e-24`.\n\nThis parser has arity 1: it produces a `scientificLitKind` node containing an atom with the text\nof the literal.\nYou can use `TSyntax.getScientific` to extract the parts from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.scientificLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">scientificLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L104-L105","name":"Lean.Parser.numLit","line":104,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.numLit","doc":"The parser `num` parses a numeric literal in several bases:\n\n* Decimal: `129`\n* Hexadecimal: `0xdeadbeef`\n* Octal: `0o755`\n* Binary: `0b1101`\n\nThis parser has arity 1: it produces a `numLitKind` node containing an atom with the text of the\nliteral.\nYou can use `TSyntax.getNat` to extract the number from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.numLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">numLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L91-L92","name":"Lean.Parser.hygieneInfo","line":91,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.hygieneInfo","doc":"The parser `hygieneInfo` parses no text, but captures the current macro scope information\nas though it parsed an identifier at the current position. It returns a `hygieneInfoKind` node\naround an `.ident` which is `Name.anonymous` but with macro scopes like a regular identifier.\n\nThis is used to implement `have := ...` syntax: the `hygieneInfo` between the `have` and `:=`\nsubstitutes for the identifier which would normally go there as in `have x :=`, so that we\ncan expand `have :=` to `have this :=` while retaining the usual macro name resolution behavior.\nSee [doc/macro_overview.md](https://github.com/leanprover/lean4/blob/master/doc/macro_overview.md)\nfor more information about macro hygiene.\n\nThis parser has arity 1: it produces a `Syntax.ident` node containing the parsed identifier.\nYou can use `TSyntax.getHygieneInfo` to extract the name from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.hygieneInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">hygieneInfo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L76-L77","name":"Lean.Parser.rawIdent","line":76,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.rawIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.rawIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">rawIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L72-L73","name":"Lean.Parser.ident","line":72,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ident","doc":"The parser `ident` parses a single identifier, possibly with namespaces, such as `foo` or\n`bar.baz`. The identifier must not be a declared token, so for example it will not match `\"def\"`\nbecause `def` is a keyword token. Tokens are implicitly declared by using them in string literals\nin parser declarations, so `syntax foo := \"bla\"` will make `bla` no longer legal as an identifier.\n\nIdentifiers can contain special characters or keywords if they are escaped using the `«»` characters:\n`«def»` is an identifier named `def`, and `«x»` is treated the same as `x`. This is useful for\nusing disallowed characters in identifiers such as `«foo.bar».baz` or `«hello world»`.\n\nThis parser has arity 1: it produces a `Syntax.ident` node containing the parsed identifier.\nYou can use `TSyntax.getId` to extract the name from the resulting syntax object. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ident\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ident</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L58-L59","name":"Lean.Parser.many1","line":58,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.many1","doc":"The parser `many1(p)`, or `p+`, repeats `p` until it fails, and returns the list of results.\n`p` must succeed at least once, or this parser will fail.\n\nNote that this parser produces the same parse tree as the `many(p)` / `p*` combinator,\nand one matches both `p*` and `p+` using `$[ .. ]*` syntax in a syntax match.\n(There is no `$[ .. ]+` syntax.)\n\nThe argument `p` is \"auto-grouped\", meaning that if the arity is greater than 1 it will be\nautomatically replaced by `group(p)` to ensure that it produces exactly 1 value.\n\nThis parser has arity 1: it produces a `nullKind` node containing one argument for each\ninvocation of `p` (or `group(p)`). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.many1\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">many1</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L43-L44","name":"Lean.Parser.many","line":43,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.many","doc":"The parser `many(p)`, or `p*`, repeats `p` until it fails, and returns the list of results.\n\nThe argument `p` is \"auto-grouped\", meaning that if the arity is greater than 1 it will be\nautomatically replaced by `group(p)` to ensure that it produces exactly 1 value.\n\nThis parser has arity 1: it produces a `nullKind` node containing one argument for each\ninvocation of `p` (or `group(p)`). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.many\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">many</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Extra.lean#L33-L34","name":"Lean.Parser.optional","line":33,"kind":"def","docLink":"./Lean/Parser/Extra.html#Lean.Parser.optional","doc":"The parser `optional(p)`, or `(p)?`, parses `p` if it succeeds,\notherwise it succeeds with no value.\n\nNote that because `?` is a legal identifier character, one must write `(p)?` or `p ?` for\nit to parse correctly. `ident?` will not work; one must write `(ident)?` instead.\n\nThis parser has arity 1: it produces a `nullKind` node containing either zero arguments\n(for the `none` case) or the list of arguments produced by `p`.\n(In particular, if `p` has arity 0 then the two cases are not differentiated!) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.optional\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">optional</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"}]}