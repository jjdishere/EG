{"name":"Lean.Parser.Term","instances":[{"typeNames":["Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil"],"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","className":"Coe"},{"typeNames":["Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil"],"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","className":"Coe"}],"imports":["Init","Lean.Parser.Attr","Lean.Parser.Level"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L729-L730","name":"Lean.Parser.Tactic.quotSeq","line":729,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">quotSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L727-L728","name":"Lean.Parser.Tactic.quot","line":727,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L722-L723","name":"Lean.Parser.Term.dotIdent","line":722,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dotIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dotIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dotIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L719-L720","name":"Lean.Parser.Term.dynamicQuot","line":719,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dynamicQuot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L716-L717","name":"Lean.Parser.Term.stateRefT","line":716,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.stateRefT","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.stateRefT\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">stateRefT</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L713-L713","name":"Lean.Parser.Term.macroLastArg","line":713,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroLastArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L712-L712","name":"Lean.Parser.Term.macroDollarArg","line":712,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroDollarArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L711-L711","name":"Lean.Parser.Term.macroArg","line":711,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L707-L708","name":"Lean.Parser.Term.assert","line":707,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.assert","doc":"`assert! cond` panics if `cond` evaluates to `false`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.assert\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">assert</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L703-L705","name":"Lean.Parser.Term.dbgTrace","line":703,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace","doc":"`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dbgTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L697-L698","name":"Lean.Parser.Term.unreachable","line":697,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unreachable","doc":"A shorthand for `panic! \"unreachable code has been reached\"`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.unreachable\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">unreachable</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L694-L695","name":"Lean.Parser.Term.panic","line":694,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.panic","doc":"`panic! msg` formally evaluates to `@Inhabited.default α` if the expected type\n`α` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.panic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">panic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L684-L684","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","line":684,"kind":"instance","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinderF</span></span>) (<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L683-L683","name":"Lean.Parser.Term.bracketedBinderF","line":683,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">bracketedBinderF</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L680-L681","name":"Lean.Parser.Term.subst","line":680,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.subst","doc":"`h ▸ e` is a macro built on top of `Eq.rec` and `Eq.symm` definitions.\nGiven `h : a = b` and `e : p a`, the term `h ▸ e` has type `p b`.\nYou can also view `h ▸ e` as a \"type casting\" operation\nwhere you change the type of `e` by using `h`.\nSee the Chapter \"Quantifiers and Equality\" in the manual\n\"Theorem Proving in Lean\" for additional information.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.subst\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">subst</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L669-L670","name":"Lean.Parser.Term.pipeCompletion","line":669,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">pipeCompletion</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L667-L668","name":"Lean.Parser.Term.pipeProj","line":667,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeProj","doc":"`e |>.x` is a shorthand for `(e).x`.\nIt is especially useful for avoiding parentheses with repeated applications.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.pipeProj\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">pipeProj</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L658-L661","name":"Lean.Parser.Term.namedPattern","line":658,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedPattern","doc":"`x@e` matches the pattern `e` and binds its value to the identifier `x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.namedPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">namedPattern</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L653-L656","name":"Lean.Parser.Term.explicitUniv","line":653,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv","doc":"`x.{u, ...}` explicitly specifies the universes `u, ...` of the constant `x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicitUniv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L648-L650","name":"Lean.Parser.Term.isIdent","line":648,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.isIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.isIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">isIdent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L645-L646","name":"Lean.Parser.Term.arrow","line":645,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.arrow","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.arrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">arrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L643-L644","name":"Lean.Parser.Term.completion","line":643,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.completion","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.completion\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">completion</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L641-L642","name":"Lean.Parser.Term.proj","line":641,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.proj","doc":"The *extended field notation* `e.f` is roughly short for `T.f e` where `T` is the type of `e`.\nMore precisely,\n* if `e` is of a function type, `e.f` is translated to `Function.f (p := e)`\n  where `p` is the first explicit parameter of function type\n* if `e` is of a named type `T ...` and there is a declaration `T.f` (possibly from `export`),\n  `e.f` is translated to `T.f (p := e)` where `p` is the first explicit parameter of type `T ...`\n* otherwise, if `e` is of a structure type,\n  the above is repeated for every base type of the structure.\n\nThe field index notation `e.i`, where `i` is a positive number,\nis short for accessing the `i`-th field (1-indexed) of `e` if it is of a structure type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.proj\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">proj</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L627-L627","name":"Lean.Parser.Term.app","line":627,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.app\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">app</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L620-L623","name":"Lean.Parser.Term.argument","line":620,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.argument","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.argument\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">argument</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L618-L619","name":"Lean.Parser.Term.ellipsis","line":618,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ellipsis","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ellipsis\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ellipsis</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L616-L617","name":"Lean.Parser.Term.namedArgument","line":616,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedArgument","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.namedArgument\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">namedArgument</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L613-L614","name":"Lean.Parser.Term.noErrorIfUnused","line":613,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused","doc":"Helper parser for marking `match`-alternatives that should not trigger errors if unused.\nWe use them to implement `macro_rules` and `elab_rules`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noErrorIfUnused</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L606-L607","name":"Lean.Parser.Term.defaultOrOfNonempty","line":606,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">defaultOrOfNonempty</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L603-L604","name":"Lean.Parser.Term.waitIfContainsMVar","line":603,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfContainsMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L601-L602","name":"Lean.Parser.Term.waitIfTypeContainsMVar","line":601,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfTypeContainsMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L599-L600","name":"Lean.Parser.Term.waitIfTypeMVar","line":599,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfTypeMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L597-L598","name":"Lean.Parser.Term.letMVar","line":597,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L594-L595","name":"Lean.Parser.Term.clear","line":594,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.clear","doc":"`clear% x; e` elaborates `x` after clearing the free variable `x` from the local context.\nIf `x` cannot be cleared (due to dependencies), it will keep `x` without failing.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.clear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L587-L588","name":"Lean.Parser.Term.noImplicitLambda","line":587,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noImplicitLambda</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L585-L586","name":"Lean.Parser.Term.ensureExpectedType","line":585,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ensureExpectedType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L583-L584","name":"Lean.Parser.Term.ensureTypeOf","line":583,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ensureTypeOf</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L581-L582","name":"Lean.Parser.Term.typeOf","line":581,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeOf","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeOf\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeOf</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L579-L580","name":"Lean.Parser.Term.withDeclName","line":579,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withDeclName","doc":"* `with_decl_name% id e` elaborates `e` in a context while changing the effective\n  declaration name to `id`.\n* `with_decl_name% ?id e` does the same, but resolves `id` as a new definition name\n  (appending the current namespaces).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.withDeclName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">withDeclName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L571-L571","name":"Lean.Parser.Term.declName","line":571,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.declName","doc":"A macro which evaluates to the name of the currently elaborating declaration. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.declName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">declName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L567-L568","name":"Lean.Parser.Term.forInMacro'","line":567,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forInMacro'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L565-L566","name":"Lean.Parser.Term.forInMacro","line":565,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forInMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L562-L563","name":"Lean.Parser.Term.unop","line":562,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.unop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">unop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L560-L561","name":"Lean.Parser.Term.binop_lazy","line":560,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binop_lazy</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L558-L559","name":"Lean.Parser.Term.binop","line":558,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L556-L557","name":"Lean.Parser.Term.binrel_no_prop","line":556,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop","doc":"Similar to `binrel`, but coerce `Prop` arguments into `Bool`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binrel_no_prop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L553-L554","name":"Lean.Parser.Term.binrel","line":553,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binrel\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binrel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L550-L551","name":"Lean.Parser.Term.noindex","line":550,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noindex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noindex\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noindex</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L547-L548","name":"Lean.Parser.Term.matchAltsWhereDecls","line":547,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAltsWhereDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L543-L544","name":"Lean.Parser.Term.whereDecls","line":543,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.whereDecls","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.whereDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">whereDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L538-L540","name":"Lean.Parser.Term.letrec","line":538,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letrec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letrec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letrec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L535-L536","name":"Lean.Parser.Term.letRecDecls","line":535,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls","doc":"`letRecDecls` matches `letRecDecl,+`, a comma-separated list of let-rec declarations (see `letRecDecl`). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letRecDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L532-L533","name":"Lean.Parser.Term.letRecDecl","line":532,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl","doc":"`letRecDecl` matches the body of a let-rec declaration: a doc comment, attributes, and then\na let declaration without the `let` keyword, such as `/-- foo -/ @[simp] bar := 1`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letRecDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L528-L529","name":"Lean.Parser.Term.attributes","line":528,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attributes","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attributes\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attributes</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L526-L526","name":"Lean.Parser.Term.attrInstance","line":526,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrInstance","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attrInstance\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attrInstance</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L525-L525","name":"Lean.Parser.Term.attrKind","line":525,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrKind","doc":"`attrKind` matches `(\"scoped\" <|> \"local\")?`, used before an attribute like `@[local simp]`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attrKind\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attrKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L523-L523","name":"Lean.Parser.Term.local","line":523,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.local","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.local\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">local</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L522-L522","name":"Lean.Parser.Term.scoped","line":522,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scoped","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.scoped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">scoped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L519-L520","name":"Lean.Parser.Term.have","line":519,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.have","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.have\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">have</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L517-L518","name":"Lean.Parser.Term.haveDecl","line":517,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveDecl","doc":"`haveDecl` matches the body of a have declaration: `have := e`, `have f x1 x2 := e`,\n`have pat := e` (where `pat` is an arbitrary term) or `have f | pat1 => e1 | pat2 => e2 ...`\n(a pattern matching declaration), except for the `have` keyword itself. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L512-L513","name":"Lean.Parser.Term.haveEqnsDecl","line":512,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveEqnsDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L510-L511","name":"Lean.Parser.Term.haveIdDecl","line":510,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveIdDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L509-L509","name":"Lean.Parser.Term.haveIdLhs","line":509,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveIdLhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L505-L506","name":"Lean.Parser.Term.let_tmp","line":505,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_tmp","doc":"`let`-declaration that is only included in the elaborated term if variable is still there.\nIt is often used when building macros.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_tmp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_tmp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L499-L500","name":"Lean.Parser.Term.let_delayed","line":499,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_delayed","doc":"`let_delayed x := v; b` is similar to `let x := v; b`, but `b` is elaborated before `v`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_delayed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_delayed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L494-L495","name":"Lean.Parser.Term.let_fun","line":494,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_fun","doc":"`let_fun x := v; b` is syntax sugar for `(fun x => b) v`.\nIt is very similar to `let x := v; b`, but they are not equivalent.\nIn `let_fun`, the value `v` has been abstracted away and cannot be accessed in `b`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_fun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_fun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L487-L488","name":"Lean.Parser.Term.let","line":487,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let","doc":"`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x => 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L461-L465","name":"Lean.Parser.Term.letDecl","line":461,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letDecl","doc":"`letDecl` matches the body of a let declaration `let f x1 x2 := e`,\n`let pat := e` (where `pat` is an arbitrary term) or `let f | pat1 => e1 | pat2 => e2 ...`\n(a pattern matching declaration), except for the `let` keyword itself.\n`let rec` declarations are not handled here. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L455-L456","name":"Lean.Parser.Term.letEqnsDecl","line":455,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letEqnsDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L437-L438","name":"Lean.Parser.Term.letPatDecl","line":437,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letPatDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L435-L436","name":"Lean.Parser.Term.letIdDecl","line":435,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L431-L434","name":"Lean.Parser.Term.letIdLhs","line":431,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdLhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L427-L429","name":"Lean.Parser.Term.letIdBinder","line":427,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L424-L425","name":"Lean.Parser.Term.doubleQuotedName","line":424,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName","doc":"A resolved name literal. Evaluates to the full name of the given constant if\nexistent in the current context, or else fails.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">doubleQuotedName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L417-L417","name":"Lean.Parser.Term.quotedName","line":417,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.quotedName","doc":"A literal of type `Name`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.quotedName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">quotedName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L414-L415","name":"Lean.Parser.Term.borrowed","line":414,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.borrowed","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.borrowed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">borrowed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L411-L412","name":"Lean.Parser.Term.trailing_parser","line":411,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">trailing_parser</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L409-L410","name":"Lean.Parser.Term.leading_parser","line":409,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.leading_parser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.leading_parser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">leading_parser</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L406-L408","name":"Lean.Parser.Term.withAnonymousAntiquot","line":406,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">withAnonymousAntiquot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L405-L405","name":"Lean.Parser.Term.optExprPrecedence","line":405,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optExprPrecedence</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L402-L403","name":"Lean.Parser.Term.fun","line":402,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fun","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.fun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">fun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L400-L401","name":"Lean.Parser.Term.basicFun","line":400,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.basicFun","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.basicFun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">basicFun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L395-L397","name":"Lean.Parser.Term.funBinder","line":395,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L390-L394","name":"Lean.Parser.Term.funStrictImplicitBinder","line":390,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funStrictImplicitBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L388-L389","name":"Lean.Parser.Term.funImplicitBinder","line":388,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funImplicitBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L386-L386","name":"Lean.Parser.Term.nomatch","line":386,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.nomatch","doc":"Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.nomatch\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">nomatch</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L378-L380","name":"Lean.Parser.Term.match","line":378,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.match","doc":"Pattern matching. `match e, ... with | p, ... => f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" <|> \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo <|> \"bar\") ...\n```\nthey are not.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.match\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">match</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L344-L346","name":"Lean.Parser.Term.motive","line":344,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.motive","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.motive\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">motive</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L340-L342","name":"Lean.Parser.Term.generalizingParam","line":340,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">generalizingParam</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L339-L339","name":"Lean.Parser.Term.falseVal","line":339,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.falseVal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.falseVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">falseVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L338-L338","name":"Lean.Parser.Term.trueVal","line":338,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trueVal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.trueVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">trueVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L335-L336","name":"Lean.Parser.Term.matchDiscr","line":335,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr","doc":"`matchDiscr` matches a \"match discriminant\", either `h : tm` or `tm`, used in `match` as\n`match h1 : e1, e2, h3 : e3 with ...`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchDiscr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L330-L331","name":"Lean.Parser.Term.matchAlts","line":330,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlts","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAlts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rhsParser : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> <span class=\"fn\">Lean.Parser.termParser</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L327-L328","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","line":327,"kind":"instance","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.matchAltExpr</span></span>) (<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.matchAlt</span></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L325-L325","name":"Lean.Parser.Term.matchAltExpr","line":325,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr","doc":"Useful for syntax quotations. Note that generic patterns such as `` `(matchAltExpr| | ... => $rhs) `` should also\nwork with other `rhsParser`s (of arity 1). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAltExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L316-L321","name":"Lean.Parser.Term.matchAlt","line":316,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAlt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rhsParser : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> <span class=\"fn\">Lean.Parser.termParser</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L311-L314","name":"Lean.Parser.Term.forall","line":311,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forall","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forall\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forall</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L307-L308","name":"Lean.Parser.Term.depArrow","line":307,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.depArrow","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.depArrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">depArrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L287-L290","name":"Lean.Parser.Term.bracketedBinder","line":287,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder","doc":"A `bracketedBinder` matches any kind of binder group that uses some kind of brackets:\n* An explicit binder like `(x y : A)`\n* An implicit binder like `{x y : A}`\n* A strict implicit binder, `⦃y z : A⦄` or its ASCII alternative `{{y z : A}}`\n* An instance binder `[A]` or `[x : A]` (multiple variables are not allowed here)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">bracketedBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L279-L280","name":"Lean.Parser.Term.instBinder","line":279,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instBinder","doc":"Instance-implicit binder. In regular applications without `@`, it is automatically inserted\nand solved by typeclass inference of the specified class.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L272-L274","name":"Lean.Parser.Term.strictImplicitBinder","line":272,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder","doc":"Strict-implicit binder. In contrast to `{ ... }` regular implicit binders,\na strict-implicit binder is inserted automatically only when at least one subsequent\nexplicit parameter is specified.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L266-L266","name":"Lean.Parser.Term.strictImplicitRightBracket","line":266,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitRightBracket</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L265-L265","name":"Lean.Parser.Term.strictImplicitLeftBracket","line":265,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitLeftBracket</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L263-L264","name":"Lean.Parser.Term.implicitBinder","line":263,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder","doc":"Implicit binder. In regular applications without `@`, it is automatically inserted\nand solved by unification whenever all explicit parameters before it are specified.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">implicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L257-L258","name":"Lean.Parser.Term.explicitBinder","line":257,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L248-L255","name":"Lean.Parser.Term.binderDefault.parenthesizer","line":248,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault.parenthesizer","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault.parenthesizer\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderDefault</span>.<span class=\"name\">parenthesizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer\">Lean.PrettyPrinter.Parenthesizer</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L244-L245","name":"Lean.Parser.Term.binderDefault","line":244,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderDefault</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L242-L243","name":"Lean.Parser.Term.binderTactic","line":242,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderTactic","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L240-L241","name":"Lean.Parser.Term.binderType","line":240,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L238-L239","name":"Lean.Parser.Term.inaccessible","line":238,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.inaccessible","doc":"`.(e)` marks an \"inaccessible pattern\", which does not influence evaluation of the pattern match, but may be necessary for type-checking.\nIn contrast to regular patterns, `e` may be an arbitrary term of the appropriate type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.inaccessible\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">inaccessible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L232-L233","name":"Lean.Parser.Term.explicit","line":232,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicit","doc":"`@x` disables automatic insertion of implicit parameters of the constant `x`.\n`@e` for any term `e` also disables the insertion of implicit lambdas at this position.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L227-L227","name":"Lean.Parser.Term.optType","line":227,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L226-L226","name":"Lean.Parser.Term.typeSpec","line":226,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeSpec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeSpec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeSpec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L221-L225","name":"Lean.Parser.Term.structInst","line":221,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInst","doc":"Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be\ninherited. If `e` is itself a variable called `x`, it can be elided:\n`fun y => { x := 1, y }`.\nA *structure update* of an existing value can be given via `with`:\n`{ point with x := 1 }`.\nThe structure type can be specified if not inferable:\n`{ x := 1, y := 2 : Point }`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInst\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInst</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L210-L211","name":"Lean.Parser.Term.optEllipsis","line":210,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optEllipsis</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L207-L209","name":"Lean.Parser.Term.structInstFieldAbbrev","line":207,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstFieldAbbrev</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L205-L206","name":"Lean.Parser.Term.structInstField","line":205,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstField","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstField\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstField</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L202-L204","name":"Lean.Parser.Term.structInstLVal","line":202,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstLVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L200-L201","name":"Lean.Parser.Term.structInstArrayRef","line":200,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstArrayRef</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L199-L199","name":"Lean.Parser.Term.show","line":199,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.show","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.show\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">show</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L197-L198","name":"Lean.Parser.Term.suffices","line":197,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.suffices","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.suffices\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">suffices</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L195-L196","name":"Lean.Parser.Term.sufficesDecl","line":195,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl","doc":"A `sufficesDecl` represents everything that comes after the `suffices` keyword:\nan optional `x :`, then a term `ty`, then `from val` or `by tac`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sufficesDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L192-L192","name":"Lean.Parser.Term.showRhs","line":192,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.showRhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.showRhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">showRhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L190-L191","name":"Lean.Parser.Term.fromTerm","line":190,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fromTerm","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.fromTerm\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">fromTerm</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L188-L189","name":"Lean.Parser.Term.optIdent","line":188,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L186-L187","name":"Lean.Parser.Term.anonymousCtor","line":186,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor","doc":"The *anonymous constructor* `⟨e, ...⟩` is equivalent to `c e ...` if the\nexpected type is an inductive type with a single constructor `c`.\nIf more terms are given than `c` has parameters, the remaining arguments\nare turned into a new anonymous constructor application. For example,\n`⟨a, b, c⟩ : α × (β × γ)` is equivalent to `⟨a, ⟨b, c⟩⟩`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">anonymousCtor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L177-L178","name":"Lean.Parser.Term.paren","line":177,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.paren","doc":"Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.paren\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">paren</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L166-L167","name":"Lean.Parser.Term.tuple","line":166,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.tuple","doc":"Tuple notation; `()` is short for `Unit.unit`, `(a, b, c)` for `Prod.mk a (Prod.mk b c)`, etc. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.tuple\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">tuple</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L163-L164","name":"Lean.Parser.Term.typeAscription","line":163,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeAscription","doc":"Type ascription notation: `(0 : Int)` instructs Lean to process `0` as a value of type `Int`.\nAn empty type ascription `(e :)` elaborates `e` without the expected type.\nThis is occasionally useful when Lean's heuristics for filling arguments from the expected type\ndo not yield the right result.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeAscription\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeAscription</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L155-L156","name":"Lean.Parser.Term.cdot","line":155,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.cdot","doc":"A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.\nFor example, `(· + ·)` is equivalent to `fun x y => x + y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.cdot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">cdot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L149-L150","name":"Lean.Parser.Term.sorry","line":149,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sorry","doc":"A temporary placeholder for a missing proof or value. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sorry\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sorry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L147-L147","name":"Lean.Parser.Term.binderIdent","line":147,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L145-L146","name":"Lean.Parser.Term.syntheticHole","line":145,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole","doc":"Parses a \"synthetic hole\", that is, `?foo` or `?_`.\nThis syntax is used to construct named metavariables. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">syntheticHole</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L141-L142","name":"Lean.Parser.Term.hole","line":141,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.hole","doc":"A placeholder term, to be synthesized by unification. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.hole\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">hole</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L138-L139","name":"Lean.Parser.Term.prop","line":138,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.prop","doc":"The universe of propositions. `Prop ≡ Sort 0`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.prop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">prop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L135-L136","name":"Lean.Parser.Term.sort","line":135,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sort","doc":"A specific universe in Lean's infinite hierarchy of universes. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sort\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sort</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L132-L133","name":"Lean.Parser.Term.type","line":132,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.type","doc":"A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.type\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">type</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L129-L130","name":"Lean.Parser.Term.char","line":129,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.char","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.char\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">char</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L127-L128","name":"Lean.Parser.Term.str","line":127,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.str","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.str\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">str</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L125-L126","name":"Lean.Parser.Term.scientific","line":125,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scientific","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.scientific\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">scientific</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L123-L124","name":"Lean.Parser.Term.num","line":123,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.num","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.num\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">num</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L121-L122","name":"Lean.Parser.Term.ident","line":121,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ident","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ident\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ident</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L117-L118","name":"Lean.Parser.Term.optSemicolon","line":117,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L113-L114","name":"Lean.Parser.Term.byTactic'","line":113,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">byTactic'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L104-L105","name":"Lean.Parser.Term.byTactic","line":104,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic","doc":"`by tac` constructs a term of the expected type by running the tactic(s) `tac`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">byTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L97-L97","name":"Lean.Parser.semicolonOrLinebreak","line":97,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">semicolonOrLinebreak</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L96-L96","name":"Lean.Parser.darrow","line":96,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.darrow","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.darrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">darrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L91-L92","name":"Lean.Parser.Tactic.seq1","line":91,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.seq1","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.seq1\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">seq1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L87-L88","name":"Lean.Parser.Tactic.tacticSeqIndentGt","line":87,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqIndentGt","doc":"Same as [`tacticSeq`] but requires delimiter-free tactic sequence to have strict indentation.\nThe strict indentation requirement only apply to *nested* `by`s, as top-level `by`s do not have a\nposition set. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqIndentGt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeqIndentGt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L81-L82","name":"Lean.Parser.Tactic.tacticSeq","line":81,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq","doc":"A sequence of tactics in brackets, or a delimiter-free indented sequence of tactics.\nDelimiter-free indentation is determined by the *first* tactic of the sequence. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L76-L77","name":"Lean.Parser.Tactic.tacticSeqBracketed","line":76,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed","doc":"The syntax `{ tacs }` is an alternative syntax for `· tacs`.\nIt runs the tactics in sequence, and fails if the goal is not solved. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeqBracketed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L72-L73","name":"Lean.Parser.Tactic.tacticSeq1Indented","line":72,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeq1Indented</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L65-L66","name":"Lean.Parser.Tactic.sepBy1IndentSemicolon","line":65,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon","doc":"`sepBy1IndentSemicolon(p)` parses a (nonempty) sequence of `p` optionally followed by `;`,\nsimilar to `many1Indent(p \";\"?)`, except that if two occurrences of `p` occur on the same line,\nthe `;` is mandatory. This is used by tactic parsing, so that\n```\nexample := by\n  skip\n  skip\n```\nis legal, but `by skip skip` is not - it must be written as `by skip; skip`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">sepBy1IndentSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L52-L53","name":"Lean.Parser.Tactic.sepByIndentSemicolon","line":52,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon","doc":"`sepByIndentSemicolon(p)` parses a sequence of `p` optionally followed by `;`,\nsimilar to `manyIndent(p \";\"?)`, except that if two occurrences of `p` occur on the same line,\nthe `;` is mandatory. This is used by tactic parsing, so that\n```\nexample := by\n  skip\n  skip\n```\nis legal, but `by skip skip` is not - it must be written as `by skip; skip`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">sepByIndentSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L37-L38","name":"Lean.Parser.convParser","line":37,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.convParser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.convParser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">convParser</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rbp : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L34-L35","name":"Lean.Parser.tacticParser","line":34,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.tacticParser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.tacticParser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">tacticParser</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rbp : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L26-L27","name":"Lean.Parser.Command.docComment","line":26,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.docComment","doc":"A `docComment` parses a \"documentation comment\" like `/-- foo -/`. This is not treated like\na regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.\n\nA `docComment` node contains a `/--` atom and then the remainder of the comment, `foo -/` in this\nexample. Use `TSyntax.getDocString` to extract the body text from a doc string syntax node. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.docComment\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">docComment</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L19-L19","name":"Lean.Parser.Command.commentBody.formatter","line":19,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L17-L17","name":"Lean.Parser.Command.commentBody.parenthesizer","line":17,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span>.<span class=\"name\">parenthesizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer\">Lean.PrettyPrinter.Parenthesizer</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/339615042d9053f184393f73ef955fbdc3cd12bd/src/Lean/Parser/Term.lean#L13-L14","name":"Lean.Parser.Command.commentBody","line":13,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"}]}